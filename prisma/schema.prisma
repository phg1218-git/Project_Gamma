// ============================================
// 이어줌 (Connecting) — Prisma Schema
// ============================================

generator client {
  provider = "prisma-client-js"

  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id              String     @id @default(cuid())
  name            String?
  email           String?    @unique
  emailVerified   DateTime?
  image           String?
  profileComplete Boolean    @default(false)
  role            UserRole   @default(USER)
  status          UserStatus @default(ACTIVE)
  suspendedAt     DateTime?
  deletedAt       DateTime?
  archivedAt      DateTime?
  lastLoginAt     DateTime?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  accounts        Account[]
  sessions        Session[]
  profile         Profile?
  surveyResponse  SurveyResponse?
  sentMatches     Match[]         @relation("MatchSender")
  receivedMatches Match[]         @relation("MatchReceiver")
  chatThreadsA    ChatThread[]    @relation("ThreadUserA")
  chatThreadsB    ChatThread[]    @relation("ThreadUserB")
  messages        Message[]
  reportsFiled    Report[]        @relation("ReportReporter")
  reportsReceived Report[]        @relation("ReportReported")
  blocksGiven     Block[]         @relation("Blocker")
  blocksReceived  Block[]         @relation("Blocked")
  reviews         ProfileReview[]
  auditLogs       AuditLog[]      @relation("AdminAuditLogs")

  @@index([role])
  @@index([status])
  @@index([createdAt])
}

model Profile {
  id                String @id @default(cuid())
  userId            String @unique
  user              User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  gender            Gender
  dateOfBirth       DateTime
  nickname          String       @db.VarChar(20)
  jobCategory       JobCategory
  jobDetail         String       @db.VarChar(50)
  companyLocation   String       @db.VarChar(50)
  residenceLocation String       @db.VarChar(50)
  hometownLocation  String       @db.VarChar(50)
  personality       String       @db.VarChar(200)
  hobbies           String[]
  preferences       String[]
  mbti              MBTI
  bloodType         BloodType
  religion          Religion
  drinking          DrinkingLevel
  smoking           SmokingLevel
  minMatchScore     Int          @default(50)
  dislikedConditions String[]
  stopMatching      Boolean      @default(false)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  @@index([stopMatching])
  @@index([minMatchScore])
  @@index([gender])
}

model SurveyResponse {
  id          String   @id @default(cuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  answers     Json
  completedAt DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Match {
  id          String      @id @default(cuid())
  senderId    String
  receiverId  String
  score       Float
  breakdown   Json
  status      MatchStatus @default(PENDING)
  endedAt     DateTime?
  archivedAt  DateTime?
  endedReason String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  sender     User        @relation("MatchSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver   User        @relation("MatchReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  chatThread ChatThread?

  @@unique([senderId, receiverId])
  @@index([senderId, status])
  @@index([receiverId, status])
  @@index([score])
  @@index([archivedAt])
}

model ChatThread {
  id            String     @id @default(cuid())
  matchId       String     @unique
  userAId       String
  userBId       String
  isActive      Boolean    @default(true)
  status        ChatStatus @default(OPEN)
  closedAt      DateTime?
  endedByUserId String?
  archivedAt    DateTime?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  match     Match     @relation(fields: [matchId], references: [id], onDelete: Cascade)
  userA     User      @relation("ThreadUserA", fields: [userAId], references: [id], onDelete: Cascade)
  userB     User      @relation("ThreadUserB", fields: [userBId], references: [id], onDelete: Cascade)
  messages  Message[]

  @@index([userAId])
  @@index([userBId])
  @@index([userAId, status])
  @@index([userBId, status])
}

model Message {
  id        String   @id @default(cuid())
  threadId  String
  senderId  String
  content   String   @db.VarChar(1000)
  readAt    DateTime?
  createdAt DateTime @default(now())

  thread ChatThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender User       @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([threadId, createdAt])
  @@index([senderId])
}

model Report {
  id         String       @id @default(cuid())
  reporterId String
  reportedId String
  reason     String       @db.VarChar(300)
  status     ReportStatus @default(OPEN)
  metadata   Json?
  resolvedAt DateTime?
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  reporter User @relation("ReportReporter", fields: [reporterId], references: [id], onDelete: Cascade)
  reported User @relation("ReportReported", fields: [reportedId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([reportedId])
}

model Block {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker User @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([createdAt])
}

model ProfileReview {
  id        String       @id @default(cuid())
  userId    String
  type      ReviewType
  status    ReviewStatus @default(PENDING)
  reason    String?
  createdAt DateTime     @default(now())
  decidedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([userId])
}

model Setting {
  key       String   @id
  value     String
  updatedAt DateTime @updatedAt
}

model AuditLog {
  id          String   @id @default(cuid())
  adminUserId String
  action      String
  targetType  String
  targetId    String
  metadata    Json?
  createdAt   DateTime @default(now())

  adminUser User @relation("AdminAuditLogs", fields: [adminUserId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([action, createdAt])
  @@index([adminUserId, createdAt])
}

enum Gender {
  MALE
  FEMALE
}

enum JobCategory {
  OFFICE
  IT
  DESIGN
  MARKETING
  SALES
  FINANCE
  EDUCATION
  MEDICAL
  LAW
  ENGINEERING
  MEDIA
  SERVICE
  PUBLIC
  FREELANCE
  STUDENT
  OTHER
}

enum MBTI {
  ISTJ
  ISFJ
  INFJ
  INTJ
  ISTP
  ISFP
  INFP
  INTP
  ESTP
  ESFP
  ENFP
  ENTP
  ESTJ
  ESFJ
  ENFJ
  ENTJ
}

enum BloodType {
  A
  B
  O
  AB
}

enum Religion {
  NONE
  CHRISTIANITY
  CATHOLICISM
  BUDDHISM
  OTHER
}

enum DrinkingLevel {
  NEVER
  RARELY
  SOMETIMES
  OFTEN
}

enum SmokingLevel {
  NEVER
  QUIT
  SOMETIMES
  OFTEN
}

enum MatchStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
  ENDED
  ARCHIVED
}

enum ChatStatus {
  OPEN
  CLOSED
}

enum UserRole {
  USER
  ADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  DELETED
}

enum ReportStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
}

enum ReviewType {
  PHOTO
  BIO
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
}
